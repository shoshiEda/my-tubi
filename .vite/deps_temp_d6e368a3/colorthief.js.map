{
  "version": 3,
  "sources": ["../../node_modules/colorthief/src/color-thief.js"],
  "sourcesContent": ["/*\n * Color Thief v2.2.0\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\n\nvar CanvasImage = function (image) {\n    this.canvas  = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n\n    this.width  = this.canvas.width  = image.width;\n    this.height = this.canvas.height = image.height;\n\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.getPixelCount = function () {\n    return this.width * this.height;\n};\n\nCanvasImage.prototype.getImageData = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nvar ColorThief = function () {};\n\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\nColorThief.prototype.getColor = function(sourceImage, quality) {\n    var palette       = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n};\n\n\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\nColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {\n\n    if (typeof colorCount === 'undefined' || colorCount < 2 || colorCount > 256) {\n        colorCount = 10;\n    }\n    if (typeof quality === 'undefined' || quality < 1) {\n        quality = 10;\n    }\n\n    // Create custom CanvasImage object\n    var image      = new CanvasImage(sourceImage);\n    var imageData  = image.getImageData();\n    var pixels     = imageData.data;\n    var pixelCount = image.getPixelCount();\n\n    // Store the RGB values in an array format suitable for quantize function\n    var pixelArray = [];\n    for (var i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n        offset = i * 4;\n        r = pixels[offset + 0];\n        g = pixels[offset + 1];\n        b = pixels[offset + 2];\n        a = pixels[offset + 3];\n        // If pixel is mostly opaque and not white\n        if (a >= 125) {\n            if (!(r > 250 && g > 250 && b > 250)) {\n                pixelArray.push([r, g, b]);\n            }\n        }\n    }\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    var cmap    = MMCQ.quantize(pixelArray, colorCount);\n    var palette = cmap? cmap.palette() : null;\n\n    return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function(imageUrl, callback, quality) {\n    let sourceImage = document.createElement(\"img\");\n    var thief = this;\n    sourceImage.addEventListener('load' , function(){\n        var palette = thief.getPalette(sourceImage, 5, quality);\n        var dominantColor = palette[0];\n        callback(dominantColor, imageUrl);\n    });\n    sourceImage.src = imageUrl\n};\n\n\nColorThief.prototype.getImageData = function(imageUrl, callback) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', imageUrl, true);\n    xhr.responseType = 'arraybuffer'\n    xhr.onload = function() {\n        if (this.status == 200) {\n            let uInt8Array = new Uint8Array(this.response)\n            i = uInt8Array.length\n            let binaryString = new Array(i);\n            for (var i = 0; i < uInt8Array.length; i++){\n                binaryString[i] = String.fromCharCode(uInt8Array[i])\n            }\n            let data = binaryString.join('')\n            let base64 = window.btoa(data)\n            callback (\"data:image/png;base64,\"+base64)\n        }\n    }\n    xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function(imageUrl, callback, quality) {\n    var thief = this;\n    this.getImageData(imageUrl, function(imageData){\n        let sourceImage = document.createElement(\"img\");\n        sourceImage.addEventListener('load' , function(){\n            var palette = thief.getPalette(sourceImage, 5, quality);\n            var dominantColor = palette[0];\n            callback(dominantColor, this);\n        });\n        sourceImage.src = imageData;\n    });\n};\n\n\n\n/*!\n * quantize.js Copyright 2008 Nick Rabinowitz.\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n * @license\n */\n\n// fill out a couple protovis dependencies\n/*!\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n * @license\n */\nif (!pv) {\n    var pv = {\n        map: function(array, f) {\n          var o = {};\n          return f ? array.map(function(d, i) { o.index = i; return f.call(o, d); }) : array.slice();\n        },\n        naturalOrder: function(a, b) {\n            return (a < b) ? -1 : ((a > b) ? 1 : 0);\n        },\n        sum: function(array, f) {\n          var o = {};\n          return array.reduce(f ? function(p, d, i) { o.index = i; return p + f.call(o, d); } : function(p, d) { return p + d; }, 0);\n        },\n        max: function(array, f) {\n          return Math.max.apply(null, f ? pv.map(array, f) : array);\n        }\n    };\n}\n\n\n\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n *\n * @author Nick Rabinowitz\n * @example\n\n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n\nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) {\n    return cmap.map(p);\n});\n\n */\nvar MMCQ = (function() {\n    // private constants\n    var sigbits = 5;\n    var rshift = 8 - sigbits;\n    var maxIterations = 1000;\n    var fractByPopulations = 0.75;\n\n    // get reduced-space color index for a pixel\n    function getColorIndex(r, g, b) {\n        return (r << (2 * sigbits)) + (g << sigbits) + b;\n    }\n\n    // Simple priority queue\n    function PQueue(comparator) {\n        var contents = [];\n        var sorted = false;\n\n        function sort() {\n            contents.sort(comparator);\n            sorted = true;\n        }\n\n        return {\n            push: function(o) {\n                contents.push(o);\n                sorted = false;\n            },\n            peek: function(index) {\n                if (!sorted) sort();\n                if (index===undefined) index = contents.length - 1;\n                return contents[index];\n            },\n            pop: function() {\n                if (!sorted) sort();\n                return contents.pop();\n            },\n            size: function() {\n                return contents.length;\n            },\n            map: function(f) {\n                return contents.map(f);\n            },\n            debug: function() {\n                if (!sorted) sort();\n                return contents;\n            }\n        };\n    }\n\n    // 3d color space box\n    function VBox(r1, r2, g1, g2, b1, b2, histo) {\n        var vbox = this;\n        vbox.r1 = r1;\n        vbox.r2 = r2;\n        vbox.g1 = g1;\n        vbox.g2 = g2;\n        vbox.b1 = b1;\n        vbox.b2 = b2;\n        vbox.histo = histo;\n    }\n    VBox.prototype = {\n        volume: function(force) {\n            var vbox = this;\n            if (!vbox._volume || force) {\n                vbox._volume = ((vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1));\n            }\n            return vbox._volume;\n        },\n        count: function(force) {\n            var vbox = this;\n            var histo = vbox.histo;\n            if (!vbox._count_set || force) {\n                var npix = 0;\n                var index; var i; var j; var k;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                             index = getColorIndex(i,j,k);\n                             npix += (histo[index] || 0);\n                        }\n                    }\n                }\n                vbox._count = npix;\n                vbox._count_set = true;\n            }\n            return vbox._count;\n        },\n        copy: function() {\n            var vbox = this;\n            return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n        },\n        avg: function(force) {\n            var vbox = this;\n            var histo = vbox.histo;\n            if (!vbox._avg || force) {\n                var ntot = 0;\n                var mult = 1 << (8 - sigbits);\n                var rsum = 0;\n                var gsum = 0;\n                var bsum = 0;\n                var hval;\n                var i, j, k;\n                var histoindex;\n                for (i = vbox.r1; i <= vbox.r2; i++) {\n                    for (j = vbox.g1; j <= vbox.g2; j++) {\n                        for (k = vbox.b1; k <= vbox.b2; k++) {\n                             histoindex = getColorIndex(i,j,k);\n                             hval = histo[histoindex] || 0;\n                             ntot += hval;\n                             rsum += (hval * (i + 0.5) * mult);\n                             gsum += (hval * (j + 0.5) * mult);\n                             bsum += (hval * (k + 0.5) * mult);\n                        }\n                    }\n                }\n                if (ntot) {\n                    vbox._avg = [~~(rsum/ntot), ~~(gsum/ntot), ~~(bsum/ntot)];\n                } else {\n                    // console.log('empty box');\n                    vbox._avg = [\n                        ~~(mult * (vbox.r1 + vbox.r2 + 1) / 2),\n                        ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2),\n                        ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)\n                    ];\n                }\n            }\n            return vbox._avg;\n        },\n        contains: function(pixel) {\n            var vbox = this;\n            var rval = pixel[0] >> rshift;\n            var gval = pixel[1] >> rshift;\n            var bval = pixel[2] >> rshift;\n            return (rval >= vbox.r1 && rval <= vbox.r2 &&\n                    gval >= vbox.g1 && gval <= vbox.g2 &&\n                    bval >= vbox.b1 && bval <= vbox.b2);\n        }\n    };\n\n    // Color map\n    function CMap() {\n        this.vboxes = new PQueue(function(a,b) {\n            return pv.naturalOrder(\n                a.vbox.count()*a.vbox.volume(),\n                b.vbox.count()*b.vbox.volume()\n            );\n        });\n    }\n    CMap.prototype = {\n        push: function(vbox) {\n            this.vboxes.push({\n                vbox: vbox,\n                color: vbox.avg()\n            });\n        },\n        palette: function() {\n            return this.vboxes.map(function(vb) { return vb.color; });\n        },\n        size: function() {\n            return this.vboxes.size();\n        },\n        map: function(color) {\n            var vboxes = this.vboxes;\n            for (var i=0; i<vboxes.size(); i++) {\n                if (vboxes.peek(i).vbox.contains(color)) {\n                    return vboxes.peek(i).color;\n                }\n            }\n            return this.nearest(color);\n        },\n        nearest: function(color) {\n            var vboxes = this.vboxes;\n            var d1;\n            var d2;\n            var pColor;\n            for (var i=0; i<vboxes.size(); i++) {\n                d2 = Math.sqrt(\n                    Math.pow(color[0] - vboxes.peek(i).color[0], 2) +\n                    Math.pow(color[1] - vboxes.peek(i).color[1], 2) +\n                    Math.pow(color[2] - vboxes.peek(i).color[2], 2)\n                );\n                if (d2 < d1 || d1 === undefined) {\n                    d1 = d2;\n                    pColor = vboxes.peek(i).color;\n                }\n            }\n            return pColor;\n        },\n        forcebw: function() {\n            // XXX: won't  work yet\n            var vboxes = this.vboxes;\n            vboxes.sort(function(a,b) { return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));});\n\n            // force darkest color to black if everything < 5\n            var lowest = vboxes[0].color;\n            if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5)\n                vboxes[0].color = [0,0,0];\n\n            // force lightest color to white if everything > 251\n            var idx = vboxes.length-1;\n            var highest = vboxes[idx].color;\n            if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251)\n                vboxes[idx].color = [255,255,255];\n        }\n    };\n\n    // histo (1-d array, giving the number of pixels in\n    // each quantized region of color space), or null on error\n    function getHisto(pixels) {\n        var histosize = 1 << (3 * sigbits);\n        var histo = new Array(histosize);\n        var index; var rval; var gval; var bval;\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            index = getColorIndex(rval, gval, bval);\n            histo[index] = (histo[index] || 0) + 1;\n        });\n        return histo;\n    }\n\n    function vboxFromPixels(pixels, histo) {\n        var rmin=1000000; var rmax=0;\n        var gmin=1000000; var gmax=0;\n        var bmin=1000000; var bmax=0;\n        var rval; var gval; var bval;\n        // find min/max\n        pixels.forEach(function(pixel) {\n            rval = pixel[0] >> rshift;\n            gval = pixel[1] >> rshift;\n            bval = pixel[2] >> rshift;\n            if (rval < rmin) rmin = rval;\n            else if (rval > rmax) rmax = rval;\n            if (gval < gmin) gmin = gval;\n            else if (gval > gmax) gmax = gval;\n            if (bval < bmin) bmin = bval;\n            else if (bval > bmax)  bmax = bval;\n        });\n        return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n    }\n\n    function medianCutApply(histo, vbox) {\n        if (!vbox.count()) return;\n\n        var rw = vbox.r2 - vbox.r1 + 1;\n        var gw = vbox.g2 - vbox.g1 + 1;\n        var bw = vbox.b2 - vbox.b1 + 1;\n        var maxw = pv.max([rw, gw, bw]);\n        // only one pixel, no split\n        if (vbox.count() == 1) {\n            return [vbox.copy()];\n        }\n        /* Find the partial sum arrays along the selected axis. */\n        var total = 0;\n        var partialsum = [];\n        var lookaheadsum = [];\n        var i; var j; var k; var sum; var index;\n        if (maxw == rw) {\n            for (i = vbox.r1; i <= vbox.r2; i++) {\n                sum = 0;\n                for (j = vbox.g1; j <= vbox.g2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(i,j,k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else if (maxw == gw) {\n            for (i = vbox.g1; i <= vbox.g2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.b1; k <= vbox.b2; k++) {\n                        index = getColorIndex(j,i,k);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        else {  /* maxw == bw */\n            for (i = vbox.b1; i <= vbox.b2; i++) {\n                sum = 0;\n                for (j = vbox.r1; j <= vbox.r2; j++) {\n                    for (k = vbox.g1; k <= vbox.g2; k++) {\n                        index = getColorIndex(j,k,i);\n                        sum += (histo[index] || 0);\n                    }\n                }\n                total += sum;\n                partialsum[i] = total;\n            }\n        }\n        partialsum.forEach(function(d,i) {\n            lookaheadsum[i] = total-d;\n        });\n        function doCut(color) {\n            var dim1 = color + '1';\n            var dim2 = color + '2';\n            var left; var right; var vbox1; var vbox2; var d2; var count2=0;\n            for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n                if (partialsum[i] > total / 2) {\n                    vbox1 = vbox.copy();\n                    vbox2 = vbox.copy();\n                    left = i - vbox[dim1];\n                    right = vbox[dim2] - i;\n                    if (left <= right)\n                        d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2));\n                    else d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2));\n                    // avoid 0-count boxes\n                    while (!partialsum[d2]) d2++;\n                    count2 = lookaheadsum[d2];\n                    while (!count2 && partialsum[d2-1]) count2 = lookaheadsum[--d2];\n                    // set dimensions\n                    vbox1[dim2] = d2;\n                    vbox2[dim1] = vbox1[dim2] + 1;\n//                    console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n                    return [vbox1, vbox2];\n                }\n            }\n\n        }\n        // determine the cut planes\n        return maxw == rw ? doCut('r') :\n            maxw == gw ? doCut('g') :\n            doCut('b');\n    }\n\n    function quantize(pixels, maxcolors) {\n        // short-circuit\n        if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n//            console.log('wrong number of maxcolors');\n            return false;\n        }\n\n        // XXX: check color content and convert to grayscale if insufficient\n\n        var histo = getHisto(pixels);\n        // histosize = 1 << (3 * sigbits);\n\n        // check that we aren't below maxcolors already\n        var nColors = 0;\n        histo.forEach(function() { nColors++; });\n        if (nColors <= maxcolors) {\n            // XXX: generate the new colors from the histo and return\n        }\n\n        // get the beginning vbox from the colors\n        var vbox = vboxFromPixels(pixels, histo);\n            var pq = new PQueue(function(a,b) { return pv.naturalOrder(a.count(), b.count()); });\n        pq.push(vbox);\n\n        // inner function to do the iteration\n        function iter(lh, target) {\n            var ncolors = 1;\n            var niters = 0;\n            var vbox;\n            while (niters < maxIterations) {\n                vbox = lh.pop();\n                if (!vbox.count())  { /* just put it back */\n                    lh.push(vbox);\n                    niters++;\n                    continue;\n                }\n                // do the cut\n                var vboxes = medianCutApply(histo, vbox);\n                    var vbox1 = vboxes[0];\n                    var vbox2 = vboxes[1];\n\n                if (!vbox1) {\n//                  console.log(\"vbox1 not defined; shouldn't happen!\");\n                    return;\n                }\n                lh.push(vbox1);\n                if (vbox2) {  /* vbox2 can be null */\n                    lh.push(vbox2);\n                    ncolors++;\n                }\n                if (ncolors >= target) return;\n                if (niters++ > maxIterations) {\n//                    console.log(\"infinite loop; perhaps too few pixels!\");\n                    return;\n                }\n            }\n        }\n\n        // first set of colors, sorted by population\n        iter(pq, fractByPopulations * maxcolors);\n\n        // Re-sort by the product of pixel occupancy times the size in color space.\n        var pq2 = new PQueue(function(a,b) {\n            return pv.naturalOrder(a.count()*a.volume(), b.count()*b.volume());\n        });\n        while (pq.size()) {\n            pq2.push(pq.pop());\n        }\n\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        iter(pq2, maxcolors - pq2.size());\n\n        // calculate the actual colors\n        var cmap = new CMap();\n        while (pq2.size()) {\n            cmap.push(pq2.pop());\n        }\n\n        return cmap;\n    }\n\n    return {\n        quantize: quantize\n    };\n})();\n\nexport default ColorThief;\n"],
  "mappings": "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",
  "names": ["CanvasImage", "image", "canvas", "document", "createElement", "context", "this", "getContext", "width", "height", "drawImage", "prototype", "getPixelCount", "getImageData", "ColorThief", "getColor", "sourceImage", "quality", "getPalette", "colorCount", "offset", "r", "g", "b", "pixels", "data", "pixelCount", "pixelArray", "i", "push", "cmap", "MMCQ", "quantize", "palette", "getColorFromUrl", "imageUrl", "callback", "thief", "addEventListener", "src", "xhr", "XMLHttpRequest", "open", "responseType", "onload", "status", "uInt8Array", "Uint8Array", "response", "length", "binaryString", "Array", "String", "fromCharCode", "join", "base64", "window", "btoa", "send", "getColorAsync", "imageData", "pv", "map", "array", "f", "o", "d", "index", "call", "slice", "naturalOrder", "a", "sum", "reduce", "p", "max", "Math", "apply", "sigbits", "rshift", "maxIterations", "getColorIndex", "PQueue", "comparator", "contents", "sorted", "sort", "peek", "pop", "size", "debug", "VBox", "r1", "r2", "g1", "g2", "b1", "b2", "histo", "CMap", "vboxes", "vbox", "count", "volume", "medianCutApply", "rw", "gw", "maxw", "copy", "j", "k", "total", "partialsum", "lookaheadsum", "forEach", "color", "left", "right", "vbox1", "vbox2", "d2", "dim1", "dim2", "count2", "min", "force", "_volume", "_count_set", "npix", "_count", "avg", "_avg", "hval", "ntot", "mult", "rsum", "gsum", "bsum", "contains", "pixel", "rval", "gval", "bval", "vb", "nearest", "d1", "pColor", "sqrt", "pow", "forcebw", "lowest", "idx", "highest", "maxcolors", "rmin", "rmax", "gmin", "gmax", "bmin", "bmax", "pq", "iter", "lh", "target", "ncolors", "niters", "pq2"]
}
